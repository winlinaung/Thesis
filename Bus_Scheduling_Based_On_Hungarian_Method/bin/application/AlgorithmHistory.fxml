<?xml version="1.0" encoding="UTF-8"?>

<?import java.lang.*?>
<?import javafx.scene.control.*?>
<?import javafx.scene.layout.*?>
<?import javafx.scene.control.TextArea?>
<?import javafx.scene.layout.AnchorPane?>
<?import javafx.scene.layout.StackPane?>

<StackPane prefHeight="718.0" prefWidth="1308.0" xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1" fx:controller="controllers.AlgorithmHistoryController">
   <children>
      <AnchorPane prefHeight="826.0" prefWidth="1020.0">
         <children>
            <ScrollPane layoutX="47.0" layoutY="61.0" prefHeight="654.0" prefWidth="1182.0">
               <content>
                  <TextArea prefHeight="900.0" prefWidth="1307.0" text="Munkres' Assignment Algorithm  &#10;Modified for Rectangular Matrices &#10;Notice: This page has been updated.  Earlier version is here. &#10;Assignment Problem - Let C be an nxn matrix representing the costs of each of n workers to perform any &#10;of n jobs.  The assignment problem is to assign jobs to workers so as to minimize the total cost. Since &#10;each worker can perform only one job and each job can be assigned to only one worker the assignments &#10;constitute an independent set of the matrix C.  &#10; &#10;An arbitrary assignment is shown above in which worker a is assigned job q, worker b is assigned job s &#10;and so on.  The total cost of this assignment is 23.  Can you find a lower cost assignment? Can you find &#10;the minimal cost assignment? Remember that each assignment must be unique in its row and column.  &#10;A brute-force algorithm for solving the assignment problem involves generating all independent sets of &#10;the matrix C, computing the total costs of each assignment and a search of all assignment to find a &#10;minimal-sum independent set. The complexity of this method is driven by the number of independent &#10;assignments possible in an nxn matrix. There are n choices for the first assignment, n-1 choices for the &#10;second assignment and so on, giving n! possible assignment sets. Therefore, this approach has, at least, &#10;an exponential runtime complexity.  &#10;&#10;As each assignment is chosen that row and column are eliminated from consideration.  The question is &#10;raised as to whether there is a better algorithm.  In fact there exists a polynomial runtime complexity &#10;algorithm for solving the assignment problem developed by James Munkre's in the late 1950's despite the &#10;fact that some references still describe this as a problem of exponential complexity.  &#10;The following 6-step algorithm is a modified form of the original Munkres' Assignment Algorithm &#10;(sometimes referred to as the Hungarian Algorithm).  This algorithm describes to the manual manipulation &#10;of a two-dimensional matrix by starring and priming zeros and by covering and uncovering rows and &#10;columns.  This is because, at the time of publication (1957), few people had access to a computer and &#10;the algorithm was exercised by hand.  &#10;&#10;Step 0:  Create an nxm  matrix called the cost matrix in which each element represents the cost of &#10;assigning one of n workers to one of m jobs.  Rotate the matrix so that there are at least as many &#10;columns as rows and let k=min(n,m).  &#10;&#10;Step 1:  For each row of the matrix, find the smallest element and subtract it from every element in its &#10;row.  Go to Step 2.  &#10;&#10;Step 2:  Find a zero (Z) in the resulting matrix.  If there is no starred zero in its row or column, star Z. &#10;Repeat for each element in the matrix. Go to Step 3.  &#10;&#10;Step 3:  Cover each column containing a starred zero.  If K columns are covered, the starred zeros &#10;describe a complete set of unique assignments.  In this case, Go to DONE, otherwise, Go to Step 4.  &#10;&#10;Step 4:  Find a noncovered zero and prime it.  If there is no starred zero in the row containing this primed &#10;zero, Go to Step 5.  Otherwise, cover this row and uncover the column containing the starred zero. &#10;Continue in this manner until there are no uncovered zeros left. Save the smallest uncovered value and &#10;Go to Step 6.  &#10;&#10;Step 5:  Construct a series of alternating primed and starred zeros as follows.  Let Z0 represent the &#10;uncovered primed zero found in Step 4.  Let Z1 denote the starred zero in the column of Z0 (if any). Let Z2 &#10;denote the primed zero in the row of Z1 (there will always be one).  Continue until the series terminates at &#10;a primed zero that has no starred zero in its column.  Unstar each starred zero of the series, star each &#10;primed zero of the series, erase all primes and uncover every line in the matrix.  Return to Step 3.  &#10;&#10;Step 6:  Add the value found in Step 4 to every element of each covered row, and subtract it from every &#10;element of each uncovered column.  Return to Step 4 without altering any stars, primes, or covered lines.  &#10;DONE:  Assignment pairs are indicated by the positions of the starred zeros in the cost matrix.  If C(i,j) is &#10;a starred zero, then the element associated with row i is assigned to the element associated with column &#10;j.&#10;&#10;Some of these descriptions require careful interpretation.  In Step 4, for example, the possible situations &#10;are, that there is a noncovered zero which get primed and if there is no starred zero in its row the &#10;program goes onto Step 5.  The other possible way out of Step 4 is that there are no noncovered zeros at &#10;all, in which case the program goes to Step 6.  &#10;   &#10;At first it may seem that the erratic nature of this algorithm would make its implementation &#10;difficult.  However, we can apply a few general rules of programming style to simplify this problem.  The &#10;same rules can be applied to any step-algorithm. &#10;&#10;(PDF) Tutorial on Implementation of Munkres' Assignment Algorithm. Available from: file:///home/shadowfield/Thesis/Lecture/(PDF)%20Tutorial%20on%20Implementation%20of%20Munkres'%20Assignment%20Algorithm.html [accessed Sep 16 2018].&#10;" />
               </content>
            </ScrollPane>
            <Button fx:id="BtnHomeView" layoutX="537.0" layoutY="22.0" mnemonicParsing="false" onAction="#HomeView" prefHeight="31.0" prefWidth="182.0" style="-fx-background-color: brown;" text="Return To Home" textFill="#f5f4f4" />
         </children>
      </AnchorPane>
   </children>
</StackPane>
